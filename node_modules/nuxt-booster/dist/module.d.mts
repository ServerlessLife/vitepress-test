import { join, dirname, basename, resolve } from 'pathe';
import { useLogger, installModule, createResolver, defineNuxtModule, addImportsDir, addTemplate, addPluginTemplate } from '@nuxt/kit';
import { getUserAgentRegex } from 'browserslist-useragent-regexp';
import { defu } from 'defu';
import hashSum from 'hash-sum';
import { promises } from 'fs';
import { parseDocument } from 'htmlparser2';
import { load } from 'cheerio';
import { render } from 'dom-serializer';

function getSupportedBrowserDetector(ignore) {
  if (ignore) {
    return JSON.stringify({ regex: "" });
  } else {
    return JSON.stringify({
      regex: "value"
    }).replace(
      '"value"',
      `new RegExp(${getUserAgentRegex({
        allowHigherVersions: true,
        allowZeroSubversions: true
      })})`
    );
  }
}
function getCrossorigin(crossorigin, defaultCrossOrigin) {
  crossorigin = crossorigin === true ? "anonymous" : crossorigin;
  crossorigin = crossorigin === void 0 ? defaultCrossOrigin || "anonymous" : crossorigin;
  return crossorigin;
}

const fontPrioritizationPreloadOrder = ["woff2", "woff", "truetype", "svg"];
const fontDeclarationOrder = [
  "embedded-opentype",
  "woff2",
  "woff",
  "truetype",
  "svg"
];
class FontConfig {
  constructor(fonts, aliases) {
    this.fonts = fonts;
    this.aliases = aliases;
  }
  toJSON() {
    return this.fonts.map((font) => ({
      ...font,
      variances: getVariances(font, this.aliases)
    }));
  }
  toCSS() {
    return [
      ...Array.from(this.fonts).map((font) => {
        return font.variances.map(
          (variance) => getFontFaceDeclaration(font, variance)
        );
      }).flat()
    ].join(" ");
  }
}
function getVariances(font, aliases) {
  return font.variances.map((variance) => {
    variance = { ...variance };
    const source = getPrioritizedFontPreloadSource(variance.sources);
    if (Object.keys(aliases).find((alias) => source.src.startsWith(alias))) {
      variance.src = source.src;
      variance.type = source.type;
    }
    return variance;
  });
}
function getFontFaceDeclaration(font, variance) {
  return `
    @font-face {
      font-family: '${font.family}';
      font-style: ${variance.style};
      font-weight: ${variance.weight};
      font-display: swap;
      src: ${getPrioritizedFontSources(variance.sources, font.locals)};
    }
  `;
}
function getPrioritizedFontPreloadSource(sources) {
  return [
    ...sources.sort(function(a, b) {
      return fontPrioritizationPreloadOrder.indexOf(a.type) - fontPrioritizationPreloadOrder.indexOf(b.type);
    })
  ].shift();
}
function getPrioritizedFontSources(sources, locals = []) {
  return locals.map((local) => `local('${local}')`).concat(
    sources.sort(function(a, b) {
      return fontDeclarationOrder.indexOf(a.type) - fontDeclarationOrder.indexOf(b.type);
    }).map((source) => {
      return `url('${source.src}') format('${source.type}')`;
    })
  ).join(",");
}

const MODULE_NAME = "nuxt-booster";
const logger = useLogger(MODULE_NAME);
function getModuleName(m) {
  if (Array.isArray(m)) {
    m = m[0];
  }
  return m.meta ? m.meta.name : m;
}
function isWebpackBuild(nuxt) {
  return nuxt.options.builder === "@nuxt/webpack-builder";
}
function isViteBuild(nuxt) {
  return !isWebpackBuild(nuxt);
}
const setPublicRuntimeConfig = (nuxt, options) => {
  nuxt.options.runtimeConfig.public.booster = {
    debug: options.debug,
    lazyOffsetComponent: options.lazyOffset.component,
    lazyOffsetAsset: options.lazyOffset.asset,
    usedFontaine: !options.disableNuxtFontaine
  };
};
function moduleExists(nuxt, moduleName) {
  return nuxt.options.modules?.find(
    (module) => getModuleName(module) === moduleName
  );
}
async function addNuxtFontaine(nuxt) {
  if (!moduleExists(nuxt, "@nuxtjs/fontaine")) {
    logger.info(
      `Added module \`@nuxtjs/fontaine\`, for more configuration learn more at \`https://github.com/nuxt-modules/fontaine\``
    );
    await installModule("@nuxtjs/fontaine");
  }
}
async function addNuxtImage(nuxt) {
  if (!moduleExists(nuxt, "@nuxt/image")) {
    logger.info(
      `Added module \`@nuxt/image\`, for more configuration learn more at \`https://image.nuxtjs.org/setup#configure\``
    );
    await installModule("@nuxt/image");
  }
  nuxt.hook("modules:done", () => {
    const nuxtImageOptions = getNuxtImageModuleOptions(nuxt);
    if (nuxtImageOptions && ["youtube", "vimeo"].find((alias) => !(alias in nuxtImageOptions.alias))) {
      logger.warn(
        "For using `BoosterYoutube` and `BoosterVimeo` you have to set the required domains & aliases for the `Provider` in the `@nuxt/image` options. \nLearn more https://basics.github.io/nuxt-booster/setup#nuxtimage"
      );
    }
  });
}
function getNuxtImageModuleOptions(moduleContainer) {
  return defu(
    {
      domains: [],
      alias: {},
      screens: {}
    },
    getModuleOptions(moduleContainer, "@nuxt/image", "image")
  );
}
function getModuleOptions(moduleContainer, packageName, configKey) {
  let options;
  if (configKey in moduleContainer.options) {
    options = moduleContainer.options[String(configKey)];
  } else {
    const module = [].concat(
      moduleContainer.options.modules,
      moduleContainer.options.buildModules
    ).find(
      (module2) => Array.isArray(module2) && module2[0] === packageName && module2[1]
    );
    options = module && module[1] || {};
  }
  return options;
}

function getDefaultOptions() {
  return {
    debug: false,
    crossorigin: void 0,
    disableNuxtFontaine: false,
    // If set, `@nuxtjs/fontaine` will not be integrated.
    disableNuxtImage: false,
    // If set, `@nuxt/image` will not be integrated.
    optimizeSSR: {
      cleanPreloads: true,
      cleanPrefetches: true,
      inlineStyles: true
    },
    detection: {
      performance: true,
      browserSupport: true,
      battery: true
    },
    performanceMetrics: {
      timing: {
        fcp: 800,
        dcl: 1200
        // fallback if fcp is not available (safari)
      }
    },
    fonts: [],
    targetFormats: [],
    densities: "x1 x2",
    /**
     * IntersectionObserver rootMargin for Compoennts and Assets
     */
    lazyOffset: {
      component: "0%",
      asset: "0%"
    },
    imageSizeCache: { stdTTL: 3600, checkperiod: 1800 }
  };
}
function deprecationsNotification(options) {
  if ("loader" in options) {
    logger.warn(
      "Option `loader` is deprecated, there is no integrated loader anymore."
    );
    delete options.loader;
  }
  if ("disableNuxtCritters" in options) {
    logger.warn(
      "Option `disableNuxtCritters` is deprecated, there is no integrated critters anymore."
    );
    delete options.loader;
  }
  if ("optimizePreloads" in options) {
    logger.warn(
      "Option `optimizePreloads` is deprecated, use `optimizeSSR` instead."
    );
    delete options.optimizePreloads;
  }
}

function prepareFontsConfiguartion(fontConfig) {
  const fonts = fontConfig.toJSON();
  const imports = /* @__PURE__ */ new Map();
  const preparedFonts = fonts.map((font) => {
    font.variances = font.variances.map((variance) => {
      const hash = `Font${hashSum(variance.src)}`;
      imports.set(hash, variance.src);
      return { ...variance, src: `HASH(${hash})` };
    });
    return font;
  });
  return { fonts: preparedFonts, imports };
}
function renderImports(imports) {
  return Array.from(imports.entries()).map(([hash, src]) => {
    return `import ${hash} from '${src}';`;
  });
}
function renderFonts(fonts) {
  let json = JSON.stringify(fonts, null, 2);
  json = json.replace(/"HASH\(([^)]+)\)"/g, "$1");
  return `export default ${json};`;
}
function getFontConfigTemplate(fontConfig) {
  const { imports, fonts } = prepareFontsConfiguartion(fontConfig);
  return `${renderImports(imports).join("\n")}

${renderFonts(fonts)}`;
}

var initHook = (nuxt, options = {
  manifest: [],
  cleanPreloads: true,
  cleanPrefetches: true,
  inlineStyles: true
}) => (nitro) => {
  nitro.hooks.hook("prerender:generate", async (route) => {
    const { manifest, cleanPreloads, cleanPrefetches, inlineStyles } = {
      manifest: [],
      cleanPreloads: true,
      cleanPrefetches: true,
      inlineStyles: true,
      ...options
    };
    if (!route.fileName?.endsWith(".html") || !route.contents) {
      return;
    }
    const distNuxt = join(
      nuxt.options.buildDir,
      "dist/client",
      nuxt.options.app.buildAssetsDir
    );
    const document = parseDocument(route.contents);
    const $ = load(document);
    if (isWebpackBuild(nuxt)) {
      await addedInlinedCSS($, getCSSFilesFromManifest($, manifest), {
        distNuxt,
        route
      });
    }
    if (cleanPreloads) {
      $('[rel="modulepreload"][as="script"]').remove();
      $('[rel="preload"][as="fetch"]').remove();
      $('[rel="preload"][as="style"]').remove();
    }
    if (cleanPrefetches) {
      $('[rel="prefetch"][as="script"]').remove();
      $('[rel="prefetch"][as="style"]').remove();
    }
    if (inlineStyles) {
      await prepareLinkStylesheets($, { distNuxt, route });
    }
    route.contents = render(document, { decodeEntities: false });
  });
};
function getUrlValues(css) {
  return css.match(/url\(([^)]+)\)/g) || [];
}
function prepareUrls(urls, relativeDir) {
  return urls.map((url) => {
    const value = url.trim().replace(/^url\((.*)\)$/, "$1").trim();
    if (isURL(value) || isDataURI(value)) {
      return null;
    }
    return [url, `url(${resolve(relativeDir, value)})`];
  }).filter(Boolean);
}
function isURL(value) {
  return value.startsWith("http") || value.startsWith("//");
}
function isDataURI(value) {
  return value.startsWith("data:");
}
async function prepareLinkStylesheets($, { distNuxt, route }) {
  try {
    const css = await Promise.all(
      Array.from($('link[rel="stylesheet"]')).map((el) => $(el)).filter(($el) => !isURL($el.attr("href"))).map(async ($el) => {
        const dir = dirname($el.attr("href"));
        const filepath = join(distNuxt, basename($el.attr("href")));
        const fileContent = await promises.readFile(filepath, "utf-8");
        let urls = getUrlValues(fileContent);
        urls = prepareUrls(urls, dir);
        const css2 = urls.reduce(
          (result, [a, b]) => result.replace(a, b),
          fileContent
        );
        $el.remove();
        logger.info(
          `Embed CSS File \`${basename($el.attr("href"))}\`; Route: \`${route.route}\``
        );
        return css2;
      })
    );
    if (css.length) {
      $("head").append(`<style>${css.join("")}</style>`);
    }
  } catch (error) {
    logger.error("can't embed css file.", error);
  }
}
function getCSSFilesFromManifest($, manifest) {
  const scripts = Array.from($('script[type="module"]'));
  return scripts.map((el) => {
    return manifest[String(`_${basename($(el).attr("src"))}`)]?.dynamicImports || [];
  }).flat().filter((file) => file.endsWith(".css")).map((file) => `${basename(file)}`);
}
async function addedInlinedCSS($, files, { distNuxt, route }) {
  const css = await Promise.all(
    files.map(async (filename) => {
      const css2 = await promises.readFile(
        join(distNuxt, "css", filename),
        "utf-8"
      );
      logger.info(
        `Embed CSS File \`${basename(filename)}\`; Route: \`${route.route}\``
      );
      return css2;
    })
  );
  if (css.length) {
    $("head").append(`<style>${css.join("")}</style>`);
  }
}

function optimizeSSR({ optimizeSSR: optimizeSSR2 }, nuxt) {
  const options = {
    cleanPreloads: true,
    cleanPrefetches: true,
    inlineStyles: true,
    ...typeof optimizeSSR2 === "boolean" ? {} : optimizeSSR2
  };
  if (options.inlineStyles) {
    nuxt.options.experimental.inlineSSRStyles = false;
  }
  if (isViteBuild(nuxt)) {
    nuxt.options.vite.build.manifest = false;
    if (options.inlineStyles) {
      nuxt.options.vite.build.cssCodeSplit = true;
    }
  } else if (isWebpackBuild(nuxt) && options.inlineStyles) {
    nuxt.options.webpack.extractCSS = true;
    logger.info(`Use workaround for \`SSR Styles\` in \`Webpack\`.`);
  }
  const hookOptions = {
    manifest: null,
    ...options
  };
  nuxt.hook("build:manifest", (manifest) => hookOptions.manifest = manifest);
  nuxt.hook("nitro:init", initHook(nuxt, hookOptions));
}

const registerAppEntry$1 = (filePath) => {
  return (configs) => {
    return configs.filter(({ name }) => ["client"].includes(name)).forEach((config) => {
      config.entry.app = config.entry.app.map((file) => {
        if (file.endsWith("entry")) {
          return filePath;
        }
        return file;
      });
    });
  };
};

const registerAppEntry = (filePath) => {
  return (context) => {
    const config = context.config;
    if (!("ssr" in config)) {
      config.build.rollupOptions.input = filePath;
    }
    context.entry = filePath;
  };
};

async function getFileInfo(name, file) {
  const { lookup } = await import('mime-types');
  return {
    name,
    file: await promises.readFile(file),
    mimeType: lookup(file)
  };
}
async function getTemplate(files) {
  return (await Promise.all(files.map((file) => getFileInfo(...file)))).map(
    ({ name, file, mimeType }) => `export const ${name} = new Blob([new Uint8Array([${[...file].join(
      ", "
    )}])], {type: '${mimeType}'});`
  ).join("\n");
}

var pluginTemplate = (options) => {
  let code = `import { defineNuxtPlugin, useBoosterHydrate } from '#imports';
import vFont from '#booster/directives/vFont';
import { isSupportedBrowser } from '#booster/utils/browser';
import FontList from '#booster/classes/FontList';
import { useNuxtApp, useBoosterHead, useRequestHeaders, useRequestURL, useRequestFetch } from '#imports';
import './fonts.css';`;
  if (options.mode !== "client") {
    code += `
import NodeCache from 'node-cache';
`;
  }
  code += `

export default defineNuxtPlugin({
  name: 'booster-plugin',
  enforce: 'post',
  async setup(nuxtApp) {

    const hydrate = useBoosterHydrate();

    const fontConfig = await import('./fontConfig').then(
      module => module.default || module
    );
    const fontList = new FontList(fontConfig);

    const head = useBoosterHead();

    nuxtApp.provide('booster', {
      head,
      getImageSize,
      hydrate,
      getFont: fontList.getFont.bind(fontList),
      crossorigin: ${options.crossorigin ? "'" + options.crossorigin + "'" : null},
      isBrowserSupported: () => isSupportedBrowser(${options.supportedBrowserDetector}),
      targetFormats: ${JSON.stringify(options.targetFormats)},
      densities: ${JSON.stringify(options.densities)}
    });

  },
  hooks: {
    'app:created'() {
      const { vueApp } = useNuxtApp();
      vueApp.use(vFont);
    }
  }
});

`;
  if (options.mode === "client") {
    code += `
const dimensionCache = new Map();`;
  } else {
    code += `
const dimensionCache = new NodeCache({  useClones: false, ...${JSON.stringify(options.imageSizeCache)} });`;
  }
  code += `
async function getImageSize (src) {
`;
  if (options.mode === "client") {
    code += `

  if (!dimensionCache.has(src)) {
    const { width, height } = await new Promise((resolve) => {
      const img = new global.Image();
      img.onload = () => resolve({width: img.naturalWidth, height: img.naturalHeight});
      img.src = src;
    });
    dimensionCache.set(src, { width, height });
  }
  return dimensionCache.get(src)`;
  } else {
    code += `
  const isNitroPrerender = 'x-nitro-prerender' in useRequestHeaders()

  try {
    let url = src;
    if (isNitroPrerender) {
      url = url.replace(useRequestURL().origin, '');
    }

    if (!dimensionCache.has(url)) {
      const blob = await useRequestFetch()(url);
      const { imageMeta } = await import('image-meta').then(
        module => module.default || module
      );

      const objectUrl = URL.createObjectURL(blob);
      const dimension = await fetch(objectUrl)
      .then(res => res.arrayBuffer())
      .then(Buffer.from)
      .then(imageMeta);

      URL.revokeObjectURL(objectUrl);

      dimensionCache.set(url, dimension);
    }

    return dimensionCache.get(url);
  } catch (error) {
    console.error('getImageSize: ' + src, error);
    return { width: 0, height: 0 };
  }
`;
  }
  code += `
}
`;
  return code;
};

var entryTemplate = (options) => {
  let code = `import { ${options.performanceCheck ? `run, ` : ``}hasSufficientPerformance, setup } from '#booster/utils/performance';
import { triggerRunCallback, observeBoosterButton, setupBoosterLayer, updateBoosterLayerMessage, initReducedView, hasBatteryPerformanceIssue, deprecationWarningButtonSelector } from '#booster/utils/entry';
import Deferred from '#booster/classes/Deferred';
import { isSupportedBrowser } from '#booster/utils/browser';
import {video as videoBlob} from './blobs.mjs';

`;
  if (options.webpack) {
    code += `
// webpack
(async () => {
  return await client().then(() => getEntry());
})()
`;
  } else {
    code += `
  // vite
export default entryWrapper();

function entryWrapper(){

  if (!process.server) {
    return client().then(() => getEntry());
  } else {
    return async (ctx) => (await getEntry())(ctx)
  }

};
`;
  }
  code += `
function getEntry(){
  return import('${options.entry}').then(module => module.default);
}

function client () {
  const deferred = new Deferred();

  let initialized = false
  const layerEl = window.document.getElementById('nuxt-booster-layer');

  const forceInit = ('__NUXT_BOOSTER_FORCE_INIT__' in window && window.__NUXT_BOOSTER_FORCE_INIT__);

  async function initApp(force) {

    if (initialized) {
      deferred.resolve();
    }

    document.documentElement.classList.remove('nuxt-booster-reduced-view');

    `;
  if (!options.ignore.battery) {
    code += `
    try {
      if (!force) {
        await hasBatteryPerformanceIssue(videoBlob)
      }
    } catch (error) {

      console.warn(error)

      triggerRunCallback(false);

      if (!!layerEl) {
        // User must interact via the layer.
        updateBoosterLayerMessage(layerEl, 'nuxt-booster-message-low-battery');
        return null;
      }
    }
    `;
  }
  code += `
    try {`;
  if (options.performanceCheck) {
    code += `
if (!force) {
        await run(${options.runOptions ? JSON.stringify(options.runOptions) : ""});
      }
`;
  }
  code += `

      initialized = true;

      triggerRunCallback(true);

      deferred.resolve();

    } catch (error) {

      console.warn(error)

      triggerRunCallback(false);

      if (!!layerEl) {
        // User must interact via the layer.
        updateBoosterLayerMessage(layerEl, 'nuxt-booster-message-weak-hardware');
        return null;
      }
    }

    return null;
  };

  const supportedBrowser = isSupportedBrowser(${options.supportedBrowserDetector});

  window.addEventListener('load', function () {
    if (!document.getElementById('nuxt-booster-layer')) {
      initApp(forceInit);
    } else {

      observeBoosterButton('.nuxt-booster-button-init-reduced-view', initReducedView);
      observeBoosterButton('.nuxt-booster-button-init-app', () => initApp(true));

      /* id selector will removed in future */
      deprecationWarningButtonSelector(initApp);

      setup(${options.performanceMetrics});

      if(('__NUXT_BOOSTER_AUTO_INIT__' in window && window.__NUXT_BOOSTER_AUTO_INIT__) || ((${!options.ignorePerformance} && hasSufficientPerformance()) && supportedBrowser)) {
        initApp();
      } else {
        setupBoosterLayer(layerEl, supportedBrowser)
      }

    }
  });

return deferred.promise;

}
`;
  return code;
};

const resolver = createResolver(import.meta.url);
var module = defineNuxtModule({
  meta: {
    name: "nuxt-booster",
    configKey: "booster",
    compatibility: {
      nuxt: "^3.0.x"
    }
  },
  defaults: getDefaultOptions(),
  async setup(moduleOptions, nuxt) {
    const runtimeDir = resolver.resolve("./runtime");
    nuxt.options.alias["#booster"] = runtimeDir;
    nuxt.options.build.transpile.push(runtimeDir);
    deprecationsNotification(moduleOptions);
    await addModules(nuxt, moduleOptions);
    setPublicRuntimeConfig(nuxt, moduleOptions);
    if (moduleOptions.detection.performance && nuxt.options.ssr) {
      if (isWebpackBuild(nuxt)) {
        nuxt.hook(
          "webpack:config",
          registerAppEntry$1(
            resolve(nuxt.options.buildDir, MODULE_NAME, "entry")
          )
        );
      } else {
        nuxt.hook(
          "vite:extend",
          registerAppEntry(
            resolve(nuxt.options.buildDir, MODULE_NAME, "entry.js")
          )
        );
      }
    } else {
      logger.warn(
        "Module functionality is limited without ssr and performance check"
      );
    }
    if (moduleOptions.optimizeSSR) {
      optimizeSSR(moduleOptions, nuxt);
    } else {
      logger.warn(
        "Preload optimization is disabled by module option `optimizeSSR`."
      );
    }
    await addBuildTemplates(nuxt, moduleOptions);
    addImportsDir(resolve(runtimeDir, "composables"));
  }
});
async function addBuildTemplates(nuxt, options) {
  const supportedBrowserDetector = await getSupportedBrowserDetector(
    !options.detection.browserSupport
  );
  const fontConfig = new FontConfig(options.fonts, nuxt.options.alias);
  nuxt.hook("listen", (_, listener) => {
    process.env.NUXT_BOOSTER_INTERAL_URL = `${listener.https ? "https" : "http"}://${listener.host || "localhost"}:${listener.port}`;
  });
  addTemplate({
    filename: MODULE_NAME + "/fontConfig.js",
    getContents: () => getFontConfigTemplate(fontConfig),
    write: true
  });
  addTemplate({
    filename: MODULE_NAME + "/fonts.css",
    getContents: () => `/*! booster-font-faces start */${fontConfig.toCSS()}/*! booster-font-faces end */`,
    write: true
  });
  ["client", "server"].forEach((mode) => {
    addPluginTemplate({
      getContents: () => {
        return pluginTemplate({
          mode,
          densities: options.densities,
          targetFormats: options.targetFormats,
          crossorigin: getCrossorigin(options.crossorigin),
          supportedBrowserDetector,
          loader: options.loader,
          imageSizeCache: options.imageSizeCache
        });
      },
      filename: MODULE_NAME + `/plugin.${mode}.js`,
      write: true,
      mode
    });
  });
  addTemplate({
    filename: MODULE_NAME + "/entry.js",
    getContents: () => {
      return entryTemplate({
        webpack: isWebpackBuild(nuxt),
        performanceCheck: true,
        isDev: !options.debug && process.env.NODE_ENV === "development",
        entry: join(nuxt.options.appDir, "entry"),
        runOptions: options.runOptions,
        ssr: nuxt.options.ssr,
        ignore: {
          battery: !options.detection.battery,
          performance: !options.detection.performance
        },
        performanceMetrics: JSON.stringify(options.performanceMetrics || {}),
        supportedBrowserDetector
      });
    },
    write: true
  });
  const files = [["video", resolver.resolve("assets/media/video.mp4")]];
  const mediaContent = await getTemplate(files);
  addTemplate({
    getContents: () => mediaContent,
    filename: MODULE_NAME + "/blobs.mjs",
    write: true
  });
}
async function addModules(nuxt, moduleOptions) {
  if (!moduleOptions.disableNuxtFontaine) {
    await addNuxtFontaine(nuxt);
  }
  if (!moduleOptions.disableNuxtImage) {
    if (!moduleOptions.targetFormats?.length) {
      moduleOptions.targetFormats = ["webp", "avif", "jpg|jpeg|png|gif"];
    }
    await addNuxtImage(nuxt);
  }
}

export { module as default };
